theory Rank

imports Main "HOL-Library.FuncSet" HOL.List

begin

(*All functions in Isabelle are total. In order to define a partial function, we first will define 
a total function and then introduce a predicate that assures us when the function is receiving 
values that we want*)

(*For the rank function, we need a condition that guarantees to us that given n d xs, xs has length
n and all of its entries are less then d *)
(*For the unrank function, we need a condition that guarantees to us that given n d k, k is less
then d^n*)

(************************ Rank ************************)

(*Function*)

(*
fun rank :: "nat \<Rightarrow> nat \<Rightarrow> nat list \<Rightarrow> nat" where
"rank 0 d [] = 0"
|
"rank 0 d (x#xs) = 0"
|
"rank (Suc n) d [] = 0"
|
"rank (Suc n) d (x# xs) = x*d^(n)+rank n d xs"
*)


fun rank :: "nat \<Rightarrow> nat \<Rightarrow> nat list \<Rightarrow> nat" where
"rank n d [] = 0"
|
"rank n d (x#xs) = x*d^(length xs)+rank n d xs"

(*Condition*)

definition cond_rank :: " nat \<Rightarrow> nat \<Rightarrow> nat list \<Rightarrow> bool" where
  "cond_rank n d xs \<equiv> length xs = n \<and>( \<forall> i. ( i< length xs \<longrightarrow> (xs! i <d)) )\<and> d>1"

(*xs ! i  express the i-th entry of the list xs*)


(*Examples of such conditions*)
value "cond_rank 3 2 [1,2]"
value "cond_rank 3 4 [1,2,27]"
value "cond_rank 3 4 [1,2,3]"


(*Let us now calculate the rank of some lists

For example, let us calculate the rank of [2,4,3,0,2,1,4] on the space F^7_5

First, let us verify that this list in fact is in F^n_q and, after that, calculate its rank*)

value "cond_rank 7 5 [2,4,3,0,2,1,4]"
value "rank 7 5 [2,4,3,0,2,1,4]" 



(************************ Unrank ************************)


(*Function*) 

fun unrank :: "nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat list" where 
  "unrank 0 d k = Nil"
|
"unrank (Suc n) d k = (unrank n d (k div d)) @ [k mod d]"

(*Condition*)

definition cond_unrank :: " nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> bool" where
  "cond_unrank n d k \<equiv> (k< (d^n))\<and> d> 1"

(*As an example, let us calculate the element 45684 of the set F^7_5*)

value "unrank 7 5 45684"


(************************ Rank and Unrank ************************)

(*Let us now prove that Rank and Unrank are inverse of each other*)

(*Before that, we will prove that the rank n d xs always give a number less then d^n and 
that unrank n d k always give a list of length n with entries less then d so that it is allowed
to compose the rank with unrank and unrank with rank*)


(*Inudction on xs*)

lemma rank_image2 : "(cond_rank n d xs) \<Longrightarrow> (rank n d xs < d^n)"
proof (induction xs)
  case Nil
  then show ?case
    by (simp add: cond_rank_def)
next
  case (Cons a xs)
  then show ?case
    by (simp add: cond_rank_def)


(*Induction on n)*)

lemma rank_image : "(cond_rank n d xs) \<Longrightarrow> (rank n d xs < d^n)"
proof (induction n)
  case 0
  then show "(cond_rank 0 d xs) \<Longrightarrow> (rank 0 d xs < d^0)" 
    by (simp add: cond_rank_def)
next
  case (Suc n)
  then show "(cond_rank (Suc n) d xs) \<Longrightarrow> (rank (Suc n) d xs < d^(Suc n))" 
  proof - 
    assume 1 : "cond_rank (Suc n) d xs"
    have 2 : "length xs = Suc n"
      using 1 by (simp add: cond_rank_def)
    obtain x ys where 3 : "xs = x # ys"
      using 2 by (induction xs) auto
    have 4 : "rank (Suc n) d xs = x*d^(length ys) + rank (Suc n) d ys"
      using 3 by simp



    have "rank n d xs < d ^ n" by 






(*length xs = Suc n \<and> (\<forall>i<length xs. xs ! i < d) \<and> Suc 0 < d \<Longrightarrow> rank (Suc n) d xs < d * d ^ n*)
(*theorem unrank_rank_inverse : "(cond_rank n d xs) \<Longrightarrow>  (unrank n d (rank n d xs) = xs)"*)


  
 



end